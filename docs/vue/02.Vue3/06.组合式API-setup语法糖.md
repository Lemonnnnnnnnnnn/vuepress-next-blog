---
title: setup语法糖
date: 2022-04-24 17:13:00
permalink: /pages/4b0a99/
categories:
  - 前端
  - Vue3
  - Vue
tags:
  - Vue3
  - Vue
---



## 基本使用

我们先来体验一下语法糖的便捷：

**未使用语法糖**

```javascript
<template>
    <div>
        {{ title }}
        <my-button></my-button>
    </div>
</template>

<script>
import myButton from "./my-button"
export default {
    components: {
        myButton
    },
    setup() {
        const title = ref('title')

        return {
            title,
        }
    }

}
</script>

<style lang="scss" scoped>
</style>
```

**使用语法糖**


```javascript
<template>
    <button>
        my-button
    </button>
</template>

<script setup lang="ts">

</script>

<style scoped>

</style>
```

你可以直接将整个`<script setup></script>`看作是`setup函数`，在**由setup包装的script中**
1.  直接声明的变量会被自动暴露到`template`中，可以直接使用，可以免去在`export default`中声明
2.  import导入的组件和函数不需要在`components和method`中注册，可以直接使用。
3.  我们不需要再主动通过`export default`导出当前组件，`setup语法糖`帮助我们自动完成了这一工作

-------

我们之前会从`setup()`的参数中获取`props,context`进行数据操作，我们接下来会依次介绍语法糖中这些数据的替代方案

- props == [defineProps](#defineProps)
- context.emit == [deineEmits](#deineEmits)
- context.expose == [defineExpose](#defineExpose)
- context.slots || context.attrs == [useSlots 和 useAttrs](#useSlots 和 useAttrs)


## defineProps

`defineProps` 返回一个只读对象，可以在`defineProps`的`ts`定义中看到

```js
export declare function defineProps<TypeProps>(): Readonly<TypeProps>;
```

这意味着我们如果想要修改`defineProps`返回的`props`对象是无效的————即使我们将其转化为可相应的`ref对象`:

```javascript
<template>
    <div>
        {{ title }}
        <button @click="handleClick">change title</button>
    </div>
</template>

<script setup lang="ts">
const props = defineProps({
    title: String
})


const { title } = toRefs(props)

const handleClick = () => {
    title.value = 'new title'
}

</script>

<style scoped>
</style>
```

![](https://linyc.oss-cn-beijing.aliyuncs.com/defineProps.gif)


#### TypeScript

我们需要通过**泛型**传入`props`的结构类型，再进行调用。

```ts
interface IProps {
    title: string
}

const props = defineProps<IProps>()
```

#### 默认值

我们会习惯性的在解构的变量中添加`= xxx`来设置某个变量为空时的默认值：比如：

```javascript
<template>
    <div>
        {{ title }}
    </div>
</template>

<script setup lang="ts">

const props = defineProps<{
    title : string
}>()

const { title = 123 } = props // 不会提供对title的类型检查

</script>


```

但`defineProps`只会对父组件传入时的接口处进行typeScript校验,如：

![](https://linyc.oss-cn-beijing.aliyuncs.com/20220513135719.png)

而有时我们会在子组件内对变量进行默认值设置，这时并不会进行类型校验：

```javascript
<template>
    <div>
        {{ title }}
    </div>
</template>

<script setup lang="ts">

const props = defineProps<{
    title : string
}>()

const { title = 123 } = props // 不会提供对title的类型检查

</script>


```

为此，我们需要使用**withDefaults**进行默认值的设置：

`withDefaults`的函数定义为：
```js
withDefaults(
  defineProps定义的props对象（ts类型）,
  Props的默认对象Object
)
```

```ts
interface IProps {
    title?: string
}

const props = withDefaults(defineProps<IProps>(), {
    title: 'default title' // 会提供对title的类型检查
})
```


## defineEmits

如果你对`emit`还不了解，请先阅读[emit](/pages/01162a/)。

Vue3中推荐我们对子组件暴露出的`emit`进行声明，[（为什么要进行声明）](/pages/6973ba/#emit)，我们先来看看不使用`setup语法糖`要怎么声明：

```javascript
<template>
    <div>
        <button @click="$emit('parentMethod', 5)">enlarge button</button>
    </div>
</template>

<script>

export default {
    emits : ['parentMethod'] 
}

</script>

<style lang="scss" scoped>
</style>
```

:::tip
`emits`接收数组和对象作为参数，官网介绍**对象的声明方式**可以对`emits`出的函数进行校验。

但事实上，校验不通过只会在控制台打印`Vue warn`，并不会阻止函数的执行。

因暂时没查到应用场景，这里只介绍数组的声明方式。
:::

`defineEmits`函数帮我们声明`emits`并且返回一个`emit`对象。[原本是从setup参数中取出emit对象，并在export default中声明emits](/pages/2d2098/#context)

```javascript
<template>
    <div>
        <button @click="handleClick">enlarge button</button>
    </div>
</template>

<script setup>
import { emitName } from './constants'
const emit = defineEmits([emitName])

const handleClick = () =>{
  emit('parentMethod' , 5)
}

</script>

<style lang="scss" scoped>
</style>
```

需要注意的是，在`defineEmits`中使用局部变量会导致编译报错，官方给出的解释是：因为`defineEmits`的参数会在`setup函数`外进行读取（提升到模块的范围）。

```js
const str = 'parentMethod'
defineEmits([str])

//报错： [vite] Internal server error: [@vue/compiler-sfc] defineProps() in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.
```

如果你需要使用变量，可以用`import`导入相关变量，其同样也会被提升到模块的范围。

```js
export const emitName = 'parentMethod'
```

```javascript
<template>
    <div>
        <button @click="handleClick">enlarge button</button>
    </div>
</template>

<script setup>
import { emitName } from './constants'
const emit = defineEmits([emitName])

const handleClick = () =>{
  emit('parentMethod' , 5)
}

</script>

<style lang="scss" scoped>
</style>
```

#### TypeScript

`defineEmits`的TS接口类型为:

```js
export declare function defineEmits<TypeEmit>(): TypeEmit;
```
我们可以这样定义`emit函数类型`
```js
defineEmits<{
  (参数1 : '函数名', 参数2 : 类型 , ...) : 函数返回值
}>()
```

改写一下我们刚才的例子：

```js
defineEmits<{
  (e: 'parentMethod', num: number): void
}>()
```

::: warning
函数的第一个参数必须是父组件传入的**函数名字符串**,事实上，`emit`Vue内部的处理是**单独取出第一个参数，到当前实例的_event属性（事件中心）获取对应事件。再将后续参数args传入真实事件中**。

个人的理解是，函数名会作为`key值`匹配每一个`emit`方法。只有完整匹配了函数名，后续参数的ts类型推断才会有效。
:::


## defineExpose

使用语法糖的情况下，组件默认是关闭的，也就是说如果想要访问子组件实例， `defineExpose` 是必要的。

父组件：

```javascript
<template>
    <div>
        <add :ref="el => refAdd = el"></add>
    </div>
</template>

<script setup lang="ts">
import Add from './add.vue';

const refAdd = ref(null)

onMounted(() => {
    refAdd.value.increment()
    console.log(refAdd.value.count); // undefined
    
})

</script>

<style scoped>
</style>

```

子组件:

```javascript
<template>
    <div>
        {{ count }}
        <button @click="increment">add</button>
    </div>
</template>

<script setup lang="ts">

const count = ref(0)
const increment = () => {
    count.value += 1
}

defineExpose({
    increment
})

</script>

<style scoped>
</style>
```

## useSlots 和 useAttrs

```vue
<script setup>
import { useSlots, useAttrs } from 'vue'

const slots = useSlots()
const attrs = useAttrs()
</script>
```




