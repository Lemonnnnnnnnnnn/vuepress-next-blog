---
title: 迭代器
date: 2022-05-30 11:53:33
permalink: /pages/4b282c/
categories:
  - 前端
  - JavaScript
  - ES6
tags:
  - 
---

## 可迭代协议

通常来说我们会用 `for` 循环来遍历一个数组，js内部是怎样判断一个对象是否可遍历呢？答案是 `@@iterator`属性方法（私有），可以通过常量 `Symbol.iterator` 访问它。

> [Symbol.iterator] : 一个无参数的函数，其返回值为一个符合[迭代器协议](#迭代器协议)的对象。

在迭代一个对象时，会不带参数的调用它的 `@@iterator`方法，这个方法会返回一个[迭代器（包含next方法）]()，最终返回迭代器中的value值作为当前遍历的结果。

![](https://linyc.oss-cn-beijing.aliyuncs.com/20220527173650.png)

::: tip
可以直接将 `Symbol.iterator` 和 `@@iterator` 划等号
:::


## 迭代器协议

实现了迭代器协议的对象才能被成为迭代器，迭代器协议要求实现一个`next()`方法给 `for` 循环调用，next方法必须返回一个以下格式的对象：

```js
function next(){
    return {
        done : boolean,
        value : any ,
    }
}
```

例如，实现一个1-3的迭代器：

```javascript
const myIterator = {
    number: 0,
    next: function () {
        this.number++
        if (this.number < 4) {
            return { done: false, value: this.number }
        }
        return { done: true, value: undefined }
    },
    [Symbol.iterator]: function () {
        return this
    }
}


for(let i of myIterator){
    console.log(i);  // 1,2,3
}

```

解读：
-   `Symbol.iterator`返回`this`
-   this指向当前这个携带 `next` 方法的对象
-   当前对象成为一个迭代器

![](https://linyc.oss-cn-beijing.aliyuncs.com/20220527173904.png)

同理，我们可以将一个class类转换为可迭代对象：

```javascript
class RangeIterator {
    constructor(start, end) {
        this.value = start;
        this.end = end;
    }
    [Symbol.iterator]() { return this }; // Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用。
    next() {
        const value = this.value;
        if (value < this.end) {
            this.value++;
            return { done: false, value: value };  // 每次 .next() 方法被调用都会返回同样的结果，以告诉 for-of 循环以下两个信息：( a ) 迭代是否结束；( b ) 返回值。
        } else {
            return { done: true, value: undefined };
        }
    }
}

function range(start, end) {
    return new RangeIterator(start, end);
}

/**
 * 一个 for-of 循环通过调用集合上的 [Symbol.iterator]( ) 方法进行启动。这个操作将会返回一个新的迭代对象
 * 一个迭代对象可以是具有 .next( ) 方法的任意对象。 每次循环调用一次.next()
 */
for (const val of range(0, 3)) {
    console.log(val)
}


```

## 生成器generator

生成器带有 `*` 号，生成器返回一个迭代对象，带有`next()`方法和`Symbol.iterator()`方法。它可以这样定义：

```javascript
function* range(start, end) {
    for (let i = start; i < end; i++) {
        yield i;
    }
}

const myGenerator = range(1,4)
console.log(myGenerator.next()); // { value: 1, done: false }

for(const item of range(1,4)){
    console.log(item); // 1,2,3
}
```

关于`yield`，见下图：

![](https://linyc.oss-cn-beijing.aliyuncs.com/20220527175501.png)

::: tip
如果使用for循环而不是直接调用next方法，js会帮我们拿到返回对象{done : boolean , value : any} 中的`value` ———— 和前面我们自己实现的迭代器一样。
:::

## for await of

`for await of` 用于遍历一个**异步迭代对象**———— 和拥有 `Symbol.iterator` 方法的对象被称为可迭代对象类似，拥有`Symbol.asyncIterator`方法属性的对象被称为异步迭代对象。

> Symbol.asyncIterator 符号指定了一个对象的默认异步迭代器。如果一个对象设置了这个属性，它就是异步可迭代对象，可用于for await...of循环。

**语法**

```js
for await (variable of iterable) {
  statement
}
```

`iterable` : 被迭代的对象， 与 `for of` 相比，这里的对象可以返回`Promise`， Promise`resolve`抛出的结果值将会被赋给`variable`。

**异步迭代器**

```javascript
const myAsyncIterable = {
    number : 0,
    next : function(){
        this.number ++
        if (this.number < 4) {
            return Promise.resolve({ done: false, value: this.number }) 
        }
        return Promise.resolve({ done: true, value: undefined })
    },
    [Symbol.asyncIterator](){ return this}
}

```

**迭代器**

```javascript
const myIterator = {
    number: 0,
    next: function () {
        this.number++
        if (this.number < 4) {
            return { done: false, value: this.number }
        }
        return { done: true, value: undefined }
    },
    [Symbol.iterator]: function () {
        return this
    }
}

```

可以看到，我们在迭代器的基础上做了两点改动：
1.  next函数返回一个Promise对象，Promise resolve出的对象依旧是 `done,value` 格式。我们手动调用next函数观察两个迭代器返回值的区别：

```js
console.log(myIterator.next());  // { done: false, value: 1 }
console.log(myAsyncIterable.next());  // Promise { { done: false, value: 1 } }
```

2.  将`Symbol.iterator` 更改为 `Symbol.asyncIterator`

如果我们直接用for循环来调用一个异步迭代器,将会得到一个错误 `myAsyncIterable is not iterable` ，原因是for函数尝试调用迭代器的`Symbol.iterator`方法，但没有找到，于是它判断对方并不是一个可迭代对象：

```js
try{
    for(const n of myAsyncIterable){ 
        console.log(n); 
    }
}catch(e){
    console.log(e);
}
```

因此我们要使用 `for await` 来调用迭代对象的 `Symbol.asyncIterator` 方法。它会调用迭代对象的next方法。如果next方法返回的是Promise对象，循环将阻塞，直到Promise抛出结果，for函数将取出结果中的`value`值，并根据`done`判断是否需要进行下一轮迭代。


